name: Requirements Reviewer
description: AI-powered PR review against issue requirements using Claude

branding:
  icon: 'check-circle'
  color: 'purple'

inputs:
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  branch:
    description: 'Branch name for issue extraction'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true

outputs:
  passed:
    description: 'Whether the review passed (all checks passed)'
    value: ${{ steps.extract.outputs.passed }}
  skipped:
    description: 'Whether the review was entirely skipped (no issue linked)'
    value: ${{ steps.extract.outputs.skipped }}
  result:
    description: 'JSON result from the review'
    value: ${{ steps.extract.outputs.result }}
  checks_passed:
    description: 'Number of checks that passed'
    value: ${{ steps.extract.outputs.checks_passed }}
  checks_failed:
    description: 'Number of checks that failed'
    value: ${{ steps.extract.outputs.checks_failed }}
  checks_skipped:
    description: 'Number of checks that were skipped'
    value: ${{ steps.extract.outputs.checks_skipped }}

runs:
  using: composite
  steps:
    - name: Get context
      id: context
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        mkdir -p .claude/review-context

        BRANCH="${{ inputs.branch }}"
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT

        # Extract issue number from branch name (e.g., "123-feature-name")
        ISSUE=""
        [[ $BRANCH =~ ^([0-9]+)- ]] && ISSUE="${BASH_REMATCH[1]}"

        # Fallback 1: Parse PR body for "Closes #X", "Fixes #X", "Resolves #X"
        if [ -z "$ISSUE" ]; then
          PR_BODY=$(gh pr view ${{ inputs.pr_number }} --json body --jq '.body' 2>/dev/null || echo "")
          ISSUE=$(echo "$PR_BODY" | grep -oP '(Closes|Fixes|Resolves)\s+#\K[0-9]+' | head -1 || echo "")
        fi

        # Fallback 2: Query GitHub's closingIssuesReferences API
        # This uses GitHub's native issue linking detection
        if [ -z "$ISSUE" ]; then
          ISSUE=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $pr: Int!) {
              repository(owner: $owner, name: $name) {
                pullRequest(number: $pr) {
                  closingIssuesReferences(first: 1) {
                    nodes { number }
                  }
                }
              }
            }' -f owner='${{ github.repository_owner }}' \
               -f name='${{ github.event.repository.name }}' \
               -F pr=${{ inputs.pr_number }} \
               --jq '.data.repository.pullRequest.closingIssuesReferences.nodes[0].number' 2>/dev/null || echo "")
          # Clean up null/empty responses
          [ "$ISSUE" = "null" ] && ISSUE=""
        fi

        # Fallback 3: Find any issue reference (#123) in PR body
        if [ -z "$ISSUE" ]; then
          # PR_BODY was fetched in Fallback 1, reuse it
          ISSUE=$(echo "$PR_BODY" | grep -oP '#\K[0-9]+' | head -1 || echo "")
        fi

        echo "issue=$ISSUE" >> $GITHUB_OUTPUT

        # Get changed files (gracefully handle permission errors)
        gh pr view ${{ inputs.pr_number }} --json files --jq '.files[].path' > .claude/review-context/changed.txt 2>/dev/null || touch .claude/review-context/changed.txt

        # Get issue context if available
        if [ -n "$ISSUE" ]; then
          echo "Fetching issue $ISSUE..."
          if ! gh issue view "$ISSUE" --json title,body > .claude/review-context/issue.json; then
            echo "Warning: Failed to fetch issue $ISSUE"
            echo "{}" > .claude/review-context/issue.json
          fi
        else
          echo "No issue number detected, skipping issue context"
          echo "{}" > .claude/review-context/issue.json
        fi

    - name: Validate context
      id: validate
      shell: bash
      run: |
        SKIP="false"
        SKIP_REASON=""

        # Check if changed files exist and have content
        if [ ! -s ".claude/review-context/changed.txt" ]; then
          SKIP="true"
          SKIP_REASON="No changed files found or unable to access PR data"
        fi

        # Check if issue context has actual content (not just {})
        if [ ! -f ".claude/review-context/issue.json" ]; then
          SKIP="true"
          SKIP_REASON="Could not access context files"
        elif [ "$(cat .claude/review-context/issue.json)" = "{}" ]; then
          SKIP="true"
          SKIP_REASON="No issue linked to this branch - skipping requirements review"
        fi

        echo "skip=$SKIP" >> $GITHUB_OUTPUT
        echo "skip_reason=$SKIP_REASON" >> $GITHUB_OUTPUT

    - name: Load agent prompt
      id: agent
      shell: bash
      run: |
        if [ -f ".constellos/agents/requirements.md" ]; then
          PROMPT=$(cat .constellos/agents/requirements.md)
        else
          PROMPT="# Requirements Review

        Check if changes align with issue requirements.
        - Changed files: .claude/review-context/changed.txt
        - Issue context: .claude/review-context/issue.json

        Evaluate:
        1. All acceptance criteria addressed
        2. Changes within issue scope
        3. No scope creep

        Output json {passed: bool, summary: ...}"
        fi

        echo "prompt<<ENDOFPROMPT" >> $GITHUB_OUTPUT
        echo "$PROMPT" >> $GITHUB_OUTPUT
        echo "ENDOFPROMPT" >> $GITHUB_OUTPUT

    - name: Run review
      id: review
      if: steps.validate.outputs.skip != 'true'
      uses: anthropics/claude-code-base-action@main
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        prompt: ${{ steps.agent.outputs.prompt }}

    - name: Extract result
      id: extract
      shell: bash
      run: |
        # Handle skipped case first
        if [ "${{ steps.validate.outputs.skip }}" = "true" ]; then
          REASON="${{ steps.validate.outputs.skip_reason }}"
          echo "passed=true" >> $GITHUB_OUTPUT
          echo "skipped=true" >> $GITHUB_OUTPUT
          echo "checks_passed=0" >> $GITHUB_OUTPUT
          echo "checks_failed=0" >> $GITHUB_OUTPUT
          echo "checks_skipped=3" >> $GITHUB_OUTPUT
          # Build JSON with proper escaping using jq
          RESULT=$(jq -n --arg reason "$REASON" '{
            checks: [
              {name: "Completeness", status: "skipped", result: $reason, reasoning: $reason, files: []},
              {name: "Scope", status: "skipped", result: $reason, reasoning: $reason, files: []},
              {name: "Traceability", status: "skipped", result: $reason, reasoning: $reason, files: []}
            ],
            message: $reason
          }')
          echo "result=$(echo "$RESULT" | jq -c '.')" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Initialize defaults
        CHECKS_PASSED=0
        CHECKS_FAILED=0
        CHECKS_SKIPPED=0
        PASSED="false"
        RESULT='{"checks":[],"message":"Review failed to complete"}'

        EXEC="${{ steps.review.outputs.execution_file }}"
        if [ -f "$EXEC" ]; then
          # Debug: Show what we're working with
          echo "DEBUG: Checking execution file..."
          echo "DEBUG: File exists, size: $(wc -c < "$EXEC") bytes"
          echo "DEBUG: Message types in file:"
          jq -r '.[].type' "$EXEC" 2>/dev/null | sort | uniq -c || echo "DEBUG: jq failed"

          # Get ALL text from assistant messages, joined together
          ALL_TEXT=$(jq -r '[.[] | select(.type=="assistant") | .message.content[]? | select(.type=="text") | .text] | join("\n")' "$EXEC" 2>/dev/null || echo "")
          echo "DEBUG: ALL_TEXT length: ${#ALL_TEXT}"
          echo "DEBUG: ALL_TEXT preview: ${ALL_TEXT:0:500}"
          # Strategy 1: Extract from ```json block
          JSON=$(echo "$ALL_TEXT" | sed -n '/```json/,/```/{/```/d;p;}' | head -100)

          # Strategy 2: If no json block, try to find raw JSON object with "checks" key
          if ! echo "$JSON" | jq . >/dev/null 2>&1; then
            JSON=$(echo "$ALL_TEXT" | grep -oP '\{"checks":\s*\[.*\]\s*(,"message":[^}]*)?\}' | head -1)
          fi

          # Strategy 3: Extract any JSON object starting with {"checks"
          if ! echo "$JSON" | jq . >/dev/null 2>&1; then
            JSON=$(echo "$ALL_TEXT" | perl -ne 'print if /\{"checks":\[/.../"message":/' | tr '\n' ' ')
          fi

          # Strategy 4: Use Python for robust multiline JSON extraction
          if ! echo "$JSON" | jq . >/dev/null 2>&1; then
            JSON=$(python3 -c "
import re, sys
text = sys.stdin.read()
# Find JSON with checks array
match = re.search(r'\{[^{}]*\"checks\"\s*:\s*\[.*?\]\s*(?:,\s*\"message\"\s*:\s*\"[^\"]*\")?\s*\}', text, re.DOTALL)
if match: print(match.group())
" <<< "$ALL_TEXT" 2>/dev/null)
          fi

          if echo "$JSON" | jq . >/dev/null 2>&1; then
            # Count checks by status
            CHECKS_PASSED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "passed")] | length')
            CHECKS_FAILED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "failed")] | length')
            CHECKS_SKIPPED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "skipped")] | length')

            # Only pass if ALL checks passed (no failures)
            if [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" -gt "0" ]; then
              PASSED="true"
            elif [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" = "0" ] && [ "$CHECKS_SKIPPED" -gt "0" ]; then
              PASSED="true"
            fi

            RESULT=$(echo "$JSON" | jq -c '.')
          fi
        fi

        # Always output
        echo "passed=$PASSED" >> $GITHUB_OUTPUT
        echo "skipped=false" >> $GITHUB_OUTPUT
        echo "result=$RESULT" >> $GITHUB_OUTPUT
        echo "checks_passed=$CHECKS_PASSED" >> $GITHUB_OUTPUT
        echo "checks_failed=$CHECKS_FAILED" >> $GITHUB_OUTPUT
        echo "checks_skipped=$CHECKS_SKIPPED" >> $GITHUB_OUTPUT
