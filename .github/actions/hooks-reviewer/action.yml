name: Hooks Reviewer
description: AI hooks review for Claude Code hook configurations and implementations

branding:
  icon: 'anchor'
  color: 'orange'

inputs:
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true
  hook_config:
    description: 'Hook configuration JSON to test (inline JSON or path to file)'
    required: false
    default: ''
  plugin_name:
    description: 'Plugin name to install (format: plugin-name@marketplace). If provided, the entire plugin will be installed and its hooks tested.'
    required: false
    default: ''
  hook_scripts_path:
    description: 'Path to directory containing hook scripts to review'
    required: false
    default: ''

outputs:
  passed:
    description: 'Whether the review passed (all checks passed)'
    value: ${{ steps.extract.outputs.passed }}
  result:
    description: 'JSON result from the review'
    value: ${{ steps.extract.outputs.result }}
  checks_passed:
    description: 'Number of checks that passed'
    value: ${{ steps.extract.outputs.checks_passed }}
  checks_failed:
    description: 'Number of checks that failed'
    value: ${{ steps.extract.outputs.checks_failed }}
  checks_skipped:
    description: 'Number of checks that were skipped'
    value: ${{ steps.extract.outputs.checks_skipped }}

runs:
  using: composite
  steps:
    - name: Setup context directory
      shell: bash
      run: |
        mkdir -p .claude/review-context

    - name: Get changed files
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Gracefully handle permission errors
        gh pr view ${{ inputs.pr_number }} --json files --jq '.files[].path' > .claude/review-context/changed.txt 2>/dev/null || touch .claude/review-context/changed.txt

    - name: Prepare hook configuration
      id: hook-config
      shell: bash
      env:
        HOOK_CONFIG: ${{ inputs.hook_config }}
        PLUGIN_NAME: ${{ inputs.plugin_name }}
        HOOK_SCRIPTS_PATH: ${{ inputs.hook_scripts_path }}
      run: |
        # Initialize variables
        SETTINGS_JSON='{}'
        HOOK_CONFIG_FILE=".claude/review-context/hook_config.json"
        SKIP_REVIEW="false"

        # Handle plugin installation
        if [ -n "$PLUGIN_NAME" ]; then
          echo "Installing plugin: $PLUGIN_NAME"
          # Extract plugin hooks.json path from plugin cache
          PLUGIN_PARTS=(${PLUGIN_NAME//@/ })
          PLUGIN_ID="${PLUGIN_PARTS[0]}"
          MARKETPLACE="${PLUGIN_PARTS[1]:-claude-code-plugins}"

          # Find plugin in cache
          PLUGIN_CACHE="$HOME/.claude/plugins/cache/$MARKETPLACE/$PLUGIN_ID"
          if [ -d "$PLUGIN_CACHE" ]; then
            # Get latest version
            LATEST_VERSION=$(ls -1 "$PLUGIN_CACHE" | sort -V | tail -1)
            PLUGIN_PATH="$PLUGIN_CACHE/$LATEST_VERSION"

            # Check for hooks.json
            if [ -f "$PLUGIN_PATH/hooks/hooks.json" ]; then
              cp "$PLUGIN_PATH/hooks/hooks.json" "$HOOK_CONFIG_FILE"
              echo "$PLUGIN_PATH/hooks" > .claude/review-context/hook_scripts_path.txt
              echo "Found plugin hooks at: $PLUGIN_PATH/hooks"
            elif [ -f "$PLUGIN_PATH/.claude-plugin/plugin.json" ]; then
              # Check plugin.json for custom hooks path
              HOOKS_PATH=$(jq -r '.hooks // "hooks"' "$PLUGIN_PATH/.claude-plugin/plugin.json")
              if [ -f "$PLUGIN_PATH/$HOOKS_PATH/hooks.json" ]; then
                cp "$PLUGIN_PATH/$HOOKS_PATH/hooks.json" "$HOOK_CONFIG_FILE"
                echo "$PLUGIN_PATH/$HOOKS_PATH" > .claude/review-context/hook_scripts_path.txt
              else
                echo '{"hooks":{}}' > "$HOOK_CONFIG_FILE"
                echo "No hooks.json found in plugin"
              fi
            fi

            # Build settings with plugin enabled
            SETTINGS_JSON=$(cat <<SETTINGS_EOF
        {
          "enabledPlugins": {
            "$PLUGIN_NAME": true
          }
        }
        SETTINGS_EOF
        )
          else
            echo "Plugin not found in cache: $PLUGIN_CACHE"
            echo "Attempting to use plugin hooks from changed files..."
          fi
        fi

        # Handle direct hook configuration
        if [ -n "$HOOK_CONFIG" ]; then
          # Check if it's a file path or inline JSON
          if [ -f "$HOOK_CONFIG" ]; then
            cp "$HOOK_CONFIG" "$HOOK_CONFIG_FILE"
          else
            echo "$HOOK_CONFIG" > "$HOOK_CONFIG_FILE"
          fi

          # Build settings with hooks enabled
          HOOKS_JSON=$(cat "$HOOK_CONFIG_FILE" | jq -c '.hooks // .')
          SETTINGS_JSON=$(cat <<SETTINGS_EOF
        {
          "hooks": $HOOKS_JSON
        }
        SETTINGS_EOF
        )
        fi

        # Handle hook scripts path
        if [ -n "$HOOK_SCRIPTS_PATH" ]; then
          echo "$HOOK_SCRIPTS_PATH" > .claude/review-context/hook_scripts_path.txt
        fi

        # If no config provided, look for hooks in changed files
        if [ ! -f "$HOOK_CONFIG_FILE" ] || [ ! -s "$HOOK_CONFIG_FILE" ]; then
          # Check if any hooks.json files were changed
          HOOKS_FILES=$(grep -E 'hooks\.json$|hooks/.*\.ts$|hooks/.*\.js$' .claude/review-context/changed.txt 2>/dev/null || true)
          if [ -n "$HOOKS_FILES" ]; then
            echo "Found hook files in PR changes:"
            echo "$HOOKS_FILES"

            # Find the first hooks.json
            FIRST_HOOKS_JSON=$(echo "$HOOKS_FILES" | grep 'hooks\.json$' | head -1)
            if [ -n "$FIRST_HOOKS_JSON" ] && [ -f "$FIRST_HOOKS_JSON" ]; then
              cp "$FIRST_HOOKS_JSON" "$HOOK_CONFIG_FILE"
              dirname "$FIRST_HOOKS_JSON" > .claude/review-context/hook_scripts_path.txt
            else
              echo '{}' > "$HOOK_CONFIG_FILE"
            fi
          else
            echo "No hook configuration provided and no hooks in changed files"
            SKIP_REVIEW="true"
            echo '{}' > "$HOOK_CONFIG_FILE"
          fi
        fi

        # Output settings JSON for the agent
        echo "settings_json<<SETTINGS_EOF" >> $GITHUB_OUTPUT
        echo "$SETTINGS_JSON" >> $GITHUB_OUTPUT
        echo "SETTINGS_EOF" >> $GITHUB_OUTPUT

        echo "skip_review=$SKIP_REVIEW" >> $GITHUB_OUTPUT

    - name: Load agent prompt
      id: agent
      shell: bash
      run: |
        if [ -f ".claude/agents/reviewers/hooks.md" ]; then
          PROMPT=$(cat .claude/agents/reviewers/hooks.md)
        else
          PROMPT="# Hooks Review
        Evaluate Claude Code hook configurations and scripts.
        Criteria: Syntax, Dependencies, Execution, Security, Integration
        Output json {checks: [...], message: ...}"
        fi

        echo "prompt<<ENDOFPROMPT" >> $GITHUB_OUTPUT
        echo "$PROMPT" >> $GITHUB_OUTPUT
        echo "ENDOFPROMPT" >> $GITHUB_OUTPUT

    - name: Skip if no hooks
      if: steps.hook-config.outputs.skip_review == 'true'
      id: skip
      shell: bash
      run: |
        echo "No hooks to review - skipping"
        RESULT=$(cat <<'RESULT_EOF'
        {
          "checks": [
            {
              "name": "Hook Syntax",
              "status": "skipped",
              "result": "No hook configuration provided",
              "reasoning": "No hooks.json or hook scripts found in PR or inputs",
              "files": []
            },
            {
              "name": "Hook Dependencies",
              "status": "skipped",
              "result": "No hooks to check",
              "reasoning": "Skipped - no hook configuration",
              "files": []
            },
            {
              "name": "Hook Execution",
              "status": "skipped",
              "result": "No hooks to check",
              "reasoning": "Skipped - no hook configuration",
              "files": []
            },
            {
              "name": "Hook Security",
              "status": "skipped",
              "result": "No hooks to check",
              "reasoning": "Skipped - no hook configuration",
              "files": []
            },
            {
              "name": "Hook Integration",
              "status": "skipped",
              "result": "No hooks to check",
              "reasoning": "Skipped - no hook configuration",
              "files": []
            }
          ],
          "message": "No hooks found to review"
        }
        RESULT_EOF
        )
        echo "skipped_result<<RESULT_EOF" >> $GITHUB_OUTPUT
        echo "$RESULT" >> $GITHUB_OUTPUT
        echo "RESULT_EOF" >> $GITHUB_OUTPUT

    - name: Run review
      if: steps.hook-config.outputs.skip_review != 'true'
      id: review
      uses: anthropics/claude-code-base-action@main
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        allowed_tools: "View,GlobTool,Grep,Bash(cat:*),Bash(ls:*),Bash(head:*),Bash(jq:*),Bash(file:*)"
        max_turns: 20
        prompt: ${{ steps.agent.outputs.prompt }}
        settings: ${{ steps.hook-config.outputs.settings_json }}

    - name: Extract result
      id: extract
      shell: bash
      run: |
        # Initialize defaults
        CHECKS_PASSED=0
        CHECKS_FAILED=0
        CHECKS_SKIPPED=0
        PASSED="false"
        RESULT='{"checks":[],"message":"Review failed to complete"}'

        # Check if we skipped
        if [ "${{ steps.hook-config.outputs.skip_review }}" = "true" ]; then
          RESULT='${{ steps.skip.outputs.skipped_result }}'
          CHECKS_SKIPPED=5
          PASSED="true"
        else
          EXEC="${{ steps.review.outputs.execution_file }}"
          if [ -f "$EXEC" ]; then
            TEXT=$(jq -r '[.[] | select(.type=="assistant") | .message.content[]? | select(.type=="text") | .text] | last // ""' "$EXEC" 2>/dev/null || echo "")
            JSON=$(echo "$TEXT" | sed -n '/```json/,/```/{/```/d;p;}' | head -50)
            if echo "$JSON" | jq . >/dev/null 2>&1; then
              # Count checks by status
              CHECKS_PASSED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "passed")] | length')
              CHECKS_FAILED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "failed")] | length')
              CHECKS_SKIPPED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "skipped")] | length')

              # Only pass if ALL checks passed (no failures)
              if [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" -gt "0" ]; then
                PASSED="true"
              elif [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" = "0" ] && [ "$CHECKS_SKIPPED" -gt "0" ]; then
                # All skipped is considered a pass
                PASSED="true"
              fi

              RESULT=$(echo "$JSON" | jq -c '.')
            fi
          fi
        fi

        # Always output
        echo "passed=$PASSED" >> $GITHUB_OUTPUT
        echo "result=$RESULT" >> $GITHUB_OUTPUT
        echo "checks_passed=$CHECKS_PASSED" >> $GITHUB_OUTPUT
        echo "checks_failed=$CHECKS_FAILED" >> $GITHUB_OUTPUT
        echo "checks_skipped=$CHECKS_SKIPPED" >> $GITHUB_OUTPUT
