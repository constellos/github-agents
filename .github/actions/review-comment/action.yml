name: Update Review Comment
description: Add or update an agent review in the consolidated CI review comment

branding:
  icon: 'message-square'
  color: 'green'

inputs:
  review_name:
    description: 'Name of the review agent (e.g., "Code Quality", "Requirements")'
    required: true
  passed:
    description: 'Whether the review passed (true/false)'
    required: true
  result_json:
    description: 'JSON result with checks array'
    required: true
  checks_passed:
    description: 'Number of checks that passed'
    required: true
  checks_failed:
    description: 'Number of checks that failed'
    required: true
  checks_skipped:
    description: 'Number of checks that were skipped'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  sha:
    description: 'Commit SHA for unique comment marker'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true
  prompt_file:
    description: 'Path to the agent prompt file'
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: Generate agent section
      id: generate
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        REVIEW="${{ inputs.review_name }}"
        PASSED="${{ inputs.passed }}"
        RESULT='${{ inputs.result_json }}'
        CHECKS_PASSED="${{ inputs.checks_passed }}"
        CHECKS_FAILED="${{ inputs.checks_failed }}"
        CHECKS_SKIPPED="${{ inputs.checks_skipped }}"
        PROMPT_FILE="${{ inputs.prompt_file }}"

        # Determine status emoji based on check counts (not just passed boolean)
        if [ "$CHECKS_PASSED" -gt 0 ] && [ "$CHECKS_FAILED" -eq 0 ]; then
          STATUS_EMOJI="✅"
        elif [ "$CHECKS_FAILED" -gt 0 ]; then
          STATUS_EMOJI="❌"
        else
          # All skipped
          STATUS_EMOJI="⚠️"
        fi

        # Build summary line with bullet separator and lowercase
        SUMMARY_PARTS=""
        [ "$CHECKS_PASSED" -gt 0 ] && SUMMARY_PARTS="✅ $CHECKS_PASSED passed"
        if [ "$CHECKS_FAILED" -gt 0 ]; then
          [ -n "$SUMMARY_PARTS" ] && SUMMARY_PARTS="$SUMMARY_PARTS • "
          SUMMARY_PARTS="${SUMMARY_PARTS}❌ $CHECKS_FAILED failed"
        fi
        if [ "$CHECKS_SKIPPED" -gt 0 ]; then
          [ -n "$SUMMARY_PARTS" ] && SUMMARY_PARTS="$SUMMARY_PARTS • "
          SUMMARY_PARTS="${SUMMARY_PARTS}⚠️ $CHECKS_SKIPPED skipped"
        fi

        # Build prompt link
        PROMPT_LINK=""
        if [ -n "$PROMPT_FILE" ]; then
          PROMPT_LINK="[View agent prompt](https://github.com/${{ github.repository }}/blob/${{ github.head_ref || github.ref_name }}/$PROMPT_FILE)"
        fi

        # Build checks table header
        CHECKS_TABLE="| Check | Status | Result | Reasoning |"
        CHECKS_TABLE="${CHECKS_TABLE}"$'\n'"|-------|--------|--------|-----------|"

        # Parse checks from JSON
        CHECKS_COUNT=$(echo "$RESULT" | jq '.checks | length' 2>/dev/null || echo "0")

        for i in $(seq 0 $((CHECKS_COUNT - 1))); do
          CHECK_NAME=$(echo "$RESULT" | jq -r ".checks[$i].name // \"Check $i\"")
          CHECK_STATUS=$(echo "$RESULT" | jq -r ".checks[$i].status // \"skipped\"")
          CHECK_RESULT=$(echo "$RESULT" | jq -r ".checks[$i].result // \"N/A\"")
          CHECK_REASONING=$(echo "$RESULT" | jq -r ".checks[$i].reasoning // \"N/A\"")

          # Status emoji for check
          case "$CHECK_STATUS" in
            "passed") CHECK_EMOJI="✅" ;;
            "failed") CHECK_EMOJI="❌" ;;
            *) CHECK_EMOJI="⚠️" ;;
          esac

          # Get files for this check
          FILES_COUNT=$(echo "$RESULT" | jq ".checks[$i].files | length" 2>/dev/null || echo "0")

          # Build files details if present
          FILES_DETAIL=""
          if [ "$FILES_COUNT" -gt 0 ]; then
            FILES_DETAIL="<details><summary>Files ($FILES_COUNT)</summary>"
            for j in $(seq 0 $((FILES_COUNT - 1))); do
              FILE_PATH=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].path // \"\"")
              FILE_LINE=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].line // \"\"")
              FILE_NOTE=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].note // \"\"")

              if [ -n "$FILE_LINE" ] && [ "$FILE_LINE" != "null" ]; then
                FILES_DETAIL="$FILES_DETAIL<br>• \`$FILE_PATH:$FILE_LINE\` - $FILE_NOTE"
              else
                FILES_DETAIL="$FILES_DETAIL<br>• \`$FILE_PATH\` - $FILE_NOTE"
              fi
            done
            FILES_DETAIL="$FILES_DETAIL</details>"
          fi

          # Escape pipe characters in content
          CHECK_RESULT=$(echo "$CHECK_RESULT" | sed 's/|/\\|/g')
          CHECK_REASONING=$(echo "$CHECK_REASONING" | sed 's/|/\\|/g')

          # Add reasoning with files detail if present
          REASONING_CELL="$CHECK_REASONING"
          [ -n "$FILES_DETAIL" ] && REASONING_CELL="$CHECK_REASONING $FILES_DETAIL"

          CHECKS_TABLE="${CHECKS_TABLE}"$'\n'"| $CHECK_NAME | $CHECK_EMOJI | $CHECK_RESULT | $REASONING_CELL |"
        done

        # Get optional message
        MESSAGE=$(echo "$RESULT" | jq -r '.message // ""' 2>/dev/null)

        # Build the full agent section
        echo "<details>" > /tmp/agent_section.md
        echo "<summary><strong>$REVIEW</strong>: $SUMMARY_PARTS</summary>" >> /tmp/agent_section.md
        echo "" >> /tmp/agent_section.md
        echo "$PROMPT_LINK" >> /tmp/agent_section.md
        echo "" >> /tmp/agent_section.md
        echo "$CHECKS_TABLE" >> /tmp/agent_section.md

        # Add message if present
        if [ -n "$MESSAGE" ] && [ "$MESSAGE" != "" ] && [ "$MESSAGE" != "null" ]; then
          echo "" >> /tmp/agent_section.md
          echo "> $MESSAGE" >> /tmp/agent_section.md
        fi

        echo "" >> /tmp/agent_section.md
        echo "</details>" >> /tmp/agent_section.md

        # Output for debugging
        echo "Generated agent section for $REVIEW"

    - name: Update review comment
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        MARKER="<!-- ci-review-${{ inputs.sha }} -->"
        AGENT_MARKER="<!-- agent:${{ inputs.review_name }} -->"
        PR="${{ inputs.pr_number }}"
        REVIEW="${{ inputs.review_name }}"
        PASSED="${{ inputs.passed }}"
        CHECKS_PASSED="${{ inputs.checks_passed }}"
        CHECKS_FAILED="${{ inputs.checks_failed }}"

        # Read the generated section
        AGENT_SECTION=$(cat /tmp/agent_section.md)

        # Wrap with markers for identification
        AGENT_BLOCK="${AGENT_MARKER}"$'\n'"${AGENT_SECTION}"$'\n'"<!-- /agent:$REVIEW -->"

        # Check for existing comment
        EXISTING=$(gh api "/repos/${{ github.repository }}/issues/$PR/comments" \
          --jq ".[] | select(.body | contains(\"$MARKER\")) | {id: .id, body: .body}" 2>/dev/null | head -1)

        if [ -n "$EXISTING" ]; then
          COMMENT_ID=$(echo "$EXISTING" | jq -r '.id')
          OLD_BODY=$(echo "$EXISTING" | jq -r '.body')

          # Remove existing agent block if present
          NEW_BODY=$(echo "$OLD_BODY" | perl -0777 -pe "s/<!-- agent:$REVIEW -->.*?<!-- \\/agent:$REVIEW -->\n?//gs")

          # Insert new agent block before the footer
          NEW_BODY=$(echo "$NEW_BODY" | sed "/^---$/i\\
        $AGENT_BLOCK
        ")

          gh api --method PATCH "/repos/${{ github.repository }}/issues/comments/$COMMENT_ID" -f body="$NEW_BODY"
        else
          # Create new comment
          {
            echo "$MARKER"
            echo "Updates on your PR checks from AI reviewers."
            echo ""
            echo "---"
            echo ""
            echo "$AGENT_BLOCK"
            echo ""
            echo "---"
            echo "*Constellos*"
          } > /tmp/comment.md

          gh pr comment "$PR" --body-file /tmp/comment.md
        fi
