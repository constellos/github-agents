name: Update Review Comment
description: Add or update an agent review in the consolidated CI review comment

branding:
  icon: 'message-square'
  color: 'green'

inputs:
  review_name:
    description: 'Name of the review agent (e.g., "Code Quality", "Requirements")'
    required: true
  passed:
    description: 'Whether the review passed (true/false)'
    required: true
  result_json:
    description: 'JSON result with checks array'
    required: true
  checks_passed:
    description: 'Number of checks that passed'
    required: true
  checks_failed:
    description: 'Number of checks that failed'
    required: true
  checks_skipped:
    description: 'Number of checks that were skipped'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  sha:
    description: 'Commit SHA for unique comment marker'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true
  prompt_file:
    description: 'Path to the agent prompt file'
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: Generate agent section
      id: generate
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        REVIEW="${{ inputs.review_name }}"
        PASSED="${{ inputs.passed }}"
        RESULT='${{ inputs.result_json }}'
        CHECKS_PASSED="${{ inputs.checks_passed }}"
        CHECKS_FAILED="${{ inputs.checks_failed }}"
        CHECKS_SKIPPED="${{ inputs.checks_skipped }}"
        PROMPT_FILE="${{ inputs.prompt_file }}"

        # Determine review type emoji
        case "$REVIEW" in
          "Requirements") REVIEW_EMOJI="ðŸ“" ;;
          "Code Quality") REVIEW_EMOJI="ðŸ”" ;;
          "Context") REVIEW_EMOJI="ðŸ“š" ;;
          "Visual") REVIEW_EMOJI="ðŸŽ¨" ;;
          "UX") REVIEW_EMOJI="ðŸ‘¤" ;;
          *) REVIEW_EMOJI="ðŸ“‹" ;;
        esac

        # Determine status emoji
        if [ "$PASSED" = "true" ]; then
          STATUS_EMOJI="âœ…"
        else
          STATUS_EMOJI="âŒ"
        fi

        # Build summary line
        SUMMARY_PARTS=""
        [ "$CHECKS_PASSED" -gt 0 ] && SUMMARY_PARTS="âœ… $CHECKS_PASSED Passed"
        if [ "$CHECKS_FAILED" -gt 0 ]; then
          [ -n "$SUMMARY_PARTS" ] && SUMMARY_PARTS="$SUMMARY_PARTS / "
          SUMMARY_PARTS="${SUMMARY_PARTS}âŒ $CHECKS_FAILED Failed"
        fi
        if [ "$CHECKS_SKIPPED" -gt 0 ]; then
          [ -n "$SUMMARY_PARTS" ] && SUMMARY_PARTS="$SUMMARY_PARTS / "
          SUMMARY_PARTS="${SUMMARY_PARTS}âš ï¸ $CHECKS_SKIPPED Skipped"
        fi

        # Build prompt link
        PROMPT_LINK=""
        if [ -n "$PROMPT_FILE" ]; then
          PROMPT_LINK="[View agent prompt](https://github.com/${{ github.repository }}/blob/${{ github.head_ref || github.ref_name }}/$PROMPT_FILE)"
        fi

        # Build checks table header
        CHECKS_TABLE="| Check | Status | Result | Reasoning |"
        CHECKS_TABLE="${CHECKS_TABLE}"$'\n'"|-------|--------|--------|-----------|"

        # Parse checks from JSON
        CHECKS_COUNT=$(echo "$RESULT" | jq '.checks | length' 2>/dev/null || echo "0")

        for i in $(seq 0 $((CHECKS_COUNT - 1))); do
          CHECK_NAME=$(echo "$RESULT" | jq -r ".checks[$i].name // \"Check $i\"")
          CHECK_STATUS=$(echo "$RESULT" | jq -r ".checks[$i].status // \"skipped\"")
          CHECK_RESULT=$(echo "$RESULT" | jq -r ".checks[$i].result // \"N/A\"")
          CHECK_REASONING=$(echo "$RESULT" | jq -r ".checks[$i].reasoning // \"N/A\"")

          # Status emoji for check
          case "$CHECK_STATUS" in
            "passed") CHECK_EMOJI="âœ…" ;;
            "failed") CHECK_EMOJI="âŒ" ;;
            *) CHECK_EMOJI="âš ï¸" ;;
          esac

          # Get files for this check
          FILES_COUNT=$(echo "$RESULT" | jq ".checks[$i].files | length" 2>/dev/null || echo "0")

          # Build files details if present
          FILES_DETAIL=""
          if [ "$FILES_COUNT" -gt 0 ]; then
            FILES_DETAIL="<details><summary>Files ($FILES_COUNT)</summary>"
            for j in $(seq 0 $((FILES_COUNT - 1))); do
              FILE_PATH=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].path // \"\"")
              FILE_LINE=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].line // \"\"")
              FILE_NOTE=$(echo "$RESULT" | jq -r ".checks[$i].files[$j].note // \"\"")

              if [ -n "$FILE_LINE" ] && [ "$FILE_LINE" != "null" ]; then
                FILES_DETAIL="$FILES_DETAIL<br>â€¢ \`$FILE_PATH:$FILE_LINE\` - $FILE_NOTE"
              else
                FILES_DETAIL="$FILES_DETAIL<br>â€¢ \`$FILE_PATH\` - $FILE_NOTE"
              fi
            done
            FILES_DETAIL="$FILES_DETAIL</details>"
          fi

          # Escape pipe characters in content
          CHECK_RESULT=$(echo "$CHECK_RESULT" | sed 's/|/\\|/g')
          CHECK_REASONING=$(echo "$CHECK_REASONING" | sed 's/|/\\|/g')

          # Add reasoning with files detail if present
          REASONING_CELL="$CHECK_REASONING"
          [ -n "$FILES_DETAIL" ] && REASONING_CELL="$CHECK_REASONING $FILES_DETAIL"

          CHECKS_TABLE="${CHECKS_TABLE}"$'\n'"| $CHECK_NAME | $CHECK_EMOJI | $CHECK_RESULT | $REASONING_CELL |"
        done

        # Get optional message
        MESSAGE=$(echo "$RESULT" | jq -r '.message // ""' 2>/dev/null)

        # Build the full agent section
        echo "<details>" > /tmp/agent_section.md
        echo "<summary>$STATUS_EMOJI $REVIEW_EMOJI <strong>$REVIEW</strong> â€” $SUMMARY_PARTS</summary>" >> /tmp/agent_section.md
        echo "" >> /tmp/agent_section.md
        echo "$PROMPT_LINK" >> /tmp/agent_section.md
        echo "" >> /tmp/agent_section.md
        echo "$CHECKS_TABLE" >> /tmp/agent_section.md

        # Add message if present
        if [ -n "$MESSAGE" ] && [ "$MESSAGE" != "" ] && [ "$MESSAGE" != "null" ]; then
          echo "" >> /tmp/agent_section.md
          echo "> $MESSAGE" >> /tmp/agent_section.md
        fi

        echo "" >> /tmp/agent_section.md
        echo "</details>" >> /tmp/agent_section.md

        # Output for debugging
        echo "Generated agent section for $REVIEW"

    - name: Update review comment
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        MARKER="<!-- ci-review-${{ inputs.sha }} -->"
        AGENT_MARKER="<!-- agent:${{ inputs.review_name }} -->"
        PR="${{ inputs.pr_number }}"
        REVIEW="${{ inputs.review_name }}"
        PASSED="${{ inputs.passed }}"
        CHECKS_PASSED="${{ inputs.checks_passed }}"
        CHECKS_FAILED="${{ inputs.checks_failed }}"

        # Read the generated section
        AGENT_SECTION=$(cat /tmp/agent_section.md)

        # Wrap with markers for identification
        AGENT_BLOCK="${AGENT_MARKER}"$'\n'"${AGENT_SECTION}"$'\n'"<!-- /agent:$REVIEW -->"

        # Check for existing comment
        EXISTING=$(gh api "/repos/${{ github.repository }}/issues/$PR/comments" \
          --jq ".[] | select(.body | contains(\"$MARKER\")) | {id: .id, body: .body}" 2>/dev/null | head -1)

        if [ -n "$EXISTING" ]; then
          COMMENT_ID=$(echo "$EXISTING" | jq -r '.id')
          OLD_BODY=$(echo "$EXISTING" | jq -r '.body')

          # Remove existing agent block if present
          NEW_BODY=$(echo "$OLD_BODY" | perl -0777 -pe "s/<!-- agent:$REVIEW -->.*?<!-- \\/agent:$REVIEW -->\n?//gs")

          # Insert new agent block before the footer
          NEW_BODY=$(echo "$NEW_BODY" | sed "/^---$/i\\
        $AGENT_BLOCK
        ")

          # Recalculate aggregate stats from all agent blocks
          TOTAL_AGENTS=$(echo "$NEW_BODY" | grep -c "<!-- agent:" || echo "0")
          TOTAL_PASSED=$(echo "$NEW_BODY" | grep -oP '(?<=<summary>)âœ…' | wc -l || echo "0")
          TOTAL_FAILED=$(echo "$NEW_BODY" | grep -oP '(?<=<summary>)âŒ' | wc -l || echo "0")

          # Update aggregate line
          if [ "$TOTAL_FAILED" -gt 0 ]; then
            AGGREGATE="**$TOTAL_AGENTS Agents**: âœ… $TOTAL_PASSED Passed / âŒ $TOTAL_FAILED Failed"
          else
            AGGREGATE="**$TOTAL_AGENTS Agents**: âœ… $TOTAL_PASSED Passed"
          fi

          # Replace aggregate line
          NEW_BODY=$(echo "$NEW_BODY" | sed "s/^\*\*[0-9]* Agents\*\*:.*/$AGGREGATE/")

          gh api --method PATCH "/repos/${{ github.repository }}/issues/comments/$COMMENT_ID" -f body="$NEW_BODY"
        else
          # Create new comment
          if [ "$PASSED" = "true" ]; then
            AGGREGATE="**1 Agent**: âœ… 1 Passed"
          else
            AGGREGATE="**1 Agent**: âŒ 1 Failed"
          fi

          # Build comment
          {
            echo "$MARKER"
            echo "## ðŸ“‹ Reviews"
            echo ""
            echo "$AGGREGATE"
            echo ""
            echo "---"
            echo ""
            echo "$AGENT_BLOCK"
            echo ""
            echo "---"
            echo "*Constellos*"
          } > /tmp/comment.md

          gh pr comment "$PR" --body-file /tmp/comment.md
        fi
