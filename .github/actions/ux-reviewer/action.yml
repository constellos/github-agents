name: UX Reviewer
description: AI UX review for interactivity, console errors, behavior

branding:
  icon: 'check-circle'
  color: 'purple'

inputs:
  claude_code_oauth_token:
    description: 'Claude Code OAuth token'
    required: true
  pr_number:
    description: 'Pull request number'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true
  e2e_results_path:
    description: 'Path to E2E test results'
    required: false
    default: 'test-results'

outputs:
  passed:
    description: 'Whether the review passed (all checks passed)'
    value: ${{ steps.extract.outputs.passed }}
  result:
    description: 'JSON result from the review'
    value: ${{ steps.extract.outputs.result }}
  checks_passed:
    description: 'Number of checks that passed'
    value: ${{ steps.extract.outputs.checks_passed }}
  checks_failed:
    description: 'Number of checks that failed'
    value: ${{ steps.extract.outputs.checks_failed }}
  checks_skipped:
    description: 'Number of checks that were skipped'
    value: ${{ steps.extract.outputs.checks_skipped }}
  console_errors:
    description: 'List of console errors found'
    value: ${{ steps.context.outputs.console_errors }}

runs:
  using: composite
  steps:
    - name: Gather UX context
      id: context
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        mkdir -p .claude/review-context

        # Get changed files (gracefully handle permission errors)
        gh pr view ${{ inputs.pr_number }} --json files --jq '.files[].path' > .claude/review-context/changed.txt 2>/dev/null || touch .claude/review-context/changed.txt

        # Check if changes affect UI/UX related files
        RELEVANT=$(grep -E '\.(tsx?|jsx?|css|scss|html|vue|svelte)$' .claude/review-context/changed.txt | wc -l || echo "0")
        echo "relevant_count=$RELEVANT" >> $GITHUB_OUTPUT

        # Extract console errors from E2E results if available
        CONSOLE_ERRORS=""
        if [ -d "${{ inputs.e2e_results_path }}" ]; then
          # Look for console errors in Playwright trace/results
          find "${{ inputs.e2e_results_path }}" -name "*.json" -exec cat {} \; 2>/dev/null | \
            jq -r '.. | .message? // empty' 2>/dev/null | \
            grep -iE 'error|warning|failed' | \
            head -20 > .claude/review-context/console_errors.txt || true

          CONSOLE_ERRORS=$(cat .claude/review-context/console_errors.txt 2>/dev/null || echo "")
        fi

        echo "console_errors<<EOF" >> $GITHUB_OUTPUT
        echo "$CONSOLE_ERRORS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Load agent prompt
      id: agent
      shell: bash
      run: |
        CONSOLE_ERRORS="${{ steps.context.outputs.console_errors }}"

        if [ -f ".claude/agents/reviewers/ux.md" ]; then
          BASE_PROMPT=$(cat .claude/agents/reviewers/ux.md)
        else
          BASE_PROMPT="# UX Review - Analyze PR for UX issues"
        fi

        if [ -n "$CONSOLE_ERRORS" ]; then
          CONTEXT="Console errors detected - please analyze"
        else
          CONTEXT="No console errors detected"
        fi

        FULL_PROMPT="$BASE_PROMPT
        $CONTEXT
        Changed files: .claude/review-context/changed.txt
        Output json {passed: bool, summary: ...}"

        echo "prompt<<ENDOFPROMPT" >> $GITHUB_OUTPUT
        echo "$FULL_PROMPT" >> $GITHUB_OUTPUT
        echo "ENDOFPROMPT" >> $GITHUB_OUTPUT

    - name: Run review
      if: steps.context.outputs.relevant_count != '0'
      id: review
      uses: anthropics/claude-code-base-action@main
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        allowed_tools: "View,GlobTool,Grep,Bash(git diff:*),Bash(cat:*),Bash(ls:*)"
        max_turns: 15
        prompt: ${{ steps.agent.outputs.prompt }}

    - name: Extract result
      id: extract
      shell: bash
      run: |
        # Initialize defaults
        CHECKS_PASSED=0
        CHECKS_FAILED=0
        CHECKS_SKIPPED=0
        PASSED="false"
        RESULT='{"checks":[],"message":"Review failed to complete"}'

        # Handle case when no UX-relevant changes exist
        if [ "${{ steps.context.outputs.relevant_count }}" = "0" ]; then
          PASSED="true"
          CHECKS_SKIPPED=5
          RESULT='{"checks":[{"name":"Error Handling","status":"skipped","result":"No UX-relevant changes","reasoning":"No UI components changed","files":[]},{"name":"Interactivity","status":"skipped","result":"No UX-relevant changes","reasoning":"No UI components changed","files":[]},{"name":"Performance Perception","status":"skipped","result":"No UX-relevant changes","reasoning":"No UI components changed","files":[]},{"name":"Navigation","status":"skipped","result":"No UX-relevant changes","reasoning":"No UI components changed","files":[]},{"name":"Accessibility Behavior","status":"skipped","result":"No UX-relevant changes","reasoning":"No UI components changed","files":[]}],"message":"No UX-relevant changes to review"}'
        else
          EXEC="${{ steps.review.outputs.execution_file }}"
          if [ -f "$EXEC" ]; then
            TEXT=$(jq -r '[.[] | select(.type=="assistant") | .message.content[]? | select(.type=="text") | .text] | last // ""' "$EXEC" 2>/dev/null || echo "")
            JSON=$(echo "$TEXT" | sed -n '/```json/,/```/{/```/d;p;}' | head -50)
            if echo "$JSON" | jq . >/dev/null 2>&1; then
              # Count checks by status
              CHECKS_PASSED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "passed")] | length')
              CHECKS_FAILED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "failed")] | length')
              CHECKS_SKIPPED=$(echo "$JSON" | jq '[.checks[]? | select(.status == "skipped")] | length')

              # Only pass if ALL checks passed (no failures)
              if [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" -gt "0" ]; then
                PASSED="true"
              elif [ "$CHECKS_FAILED" = "0" ] && [ "$CHECKS_PASSED" = "0" ] && [ "$CHECKS_SKIPPED" -gt "0" ]; then
                PASSED="true"
              fi

              RESULT=$(echo "$JSON" | jq -c '.')
            fi
          fi
        fi

        # Always output
        echo "passed=$PASSED" >> $GITHUB_OUTPUT
        echo "result=$RESULT" >> $GITHUB_OUTPUT
        echo "checks_passed=$CHECKS_PASSED" >> $GITHUB_OUTPUT
        echo "checks_failed=$CHECKS_FAILED" >> $GITHUB_OUTPUT
        echo "checks_skipped=$CHECKS_SKIPPED" >> $GITHUB_OUTPUT
