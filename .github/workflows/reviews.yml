name: Code Reviews

# Orchestrates all 6 Claude Code review types
# Runs on every commit (any branch)
# Depends on E2E Tests passing or skipping

on:
  workflow_run:
    workflows: ["E2E Tests", "Basic CI"]
    types: [completed]
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

concurrency:
  group: reviews-${{ github.ref }}
  cancel-in-progress: true

jobs:
  check-prerequisites:
    runs-on: ubuntu-latest
    outputs:
      can_proceed: ${{ steps.check.outputs.can_proceed }}
    steps:
      - name: Verify E2E passed or skipped
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            CONCLUSION="${{ github.event.workflow_run.conclusion }}"
            if [ "$CONCLUSION" != "success" ] && [ "$CONCLUSION" != "skipped" ]; then
              echo "::error::Prerequisites failed"
              echo "can_proceed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          echo "can_proceed=true" >> $GITHUB_OUTPUT

  requirements-review:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract branch context
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number from branch name patterns:
          # feature/123-description, fix/issue-456, 123-my-feature
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          elif [[ $BRANCH_NAME =~ issue-([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi

          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | tr '\n' ' ')
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | tr '\n' ' ' || echo "")
          fi
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT

      - name: Get issue content
        id: issue
        if: steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.context.outputs.issue_number }}"

          # Get issue details
          ISSUE_TITLE=$(gh issue view $ISSUE_NUM --json title --jq '.title' 2>/dev/null || echo "")
          ISSUE_BODY=$(gh issue view $ISSUE_NUM --json body --jq '.body' 2>/dev/null || echo "")

          # Get issue comments
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUM --json comments --jq '.comments[].body' 2>/dev/null | head -c 5000 || echo "")

          # Save to files for Claude to read
          echo "$ISSUE_TITLE" > /tmp/issue_title.txt
          echo "$ISSUE_BODY" > /tmp/issue_body.txt
          echo "$ISSUE_COMMENTS" > /tmp/issue_comments.txt

          echo "has_issue=true" >> $GITHUB_OUTPUT

      - name: Get PR comments
        id: pr_comments
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"

          # Get PR comments
          PR_COMMENTS=$(gh pr view $PR_NUM --json comments --jq '.comments[].body' 2>/dev/null | head -c 5000 || echo "")

          # Get review comments
          REVIEW_COMMENTS=$(gh pr view $PR_NUM --json reviews --jq '.reviews[].body' 2>/dev/null | head -c 3000 || echo "")

          echo "$PR_COMMENTS" > /tmp/pr_comments.txt
          echo "$REVIEW_COMMENTS" > /tmp/review_comments.txt

          echo "has_pr_comments=true" >> $GITHUB_OUTPUT

      - name: Requirements Review with Claude
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(git diff:*),Bash(git log:*),Bash(cat:*)"
          max_turns: 15
          prompt: |
            # Requirements Review Agent

            You are a requirements review agent. Your job is to verify that code changes align with the linked issue requirements and any comments/feedback.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue Number: ${{ steps.context.outputs.issue_number }}
            - Changed Files: ${{ steps.context.outputs.changed_files }}
            - Event: ${{ github.event_name }}
            - PR Number: ${{ github.event.pull_request.number || 'N/A' }}

            ## Your Task

            1. **Read the linked issue** (if available):
               - Issue title: Read /tmp/issue_title.txt
               - Issue body: Read /tmp/issue_body.txt
               - Issue comments: Read /tmp/issue_comments.txt

            2. **Read PR/branch comments** (if available):
               - PR comments: Read /tmp/pr_comments.txt
               - Review comments: Read /tmp/review_comments.txt

            3. **Analyze the code changes**:
               - Review git diff for the changed files
               - Understand what was implemented

            4. **Compare requirements vs implementation**:
               - Does the code address all requirements from the issue?
               - Are there any comments that indicate needed changes?
               - Are there any scope creep issues (implementation beyond requirements)?
               - Are there missing requirements?

            5. **Make your decision**:
               - PASS: All requirements addressed, comments resolved
               - FAIL: Requirements not met, unresolved feedback, or scope issues

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - **Prioritize comments** over original issue if they indicate requirement changes
            - If there's no linked issue, focus on PR comments and code quality
            - If no issue AND no comments, provide general assessment and PASS

            ## Output Format

            Provide a detailed analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "requirements_met": ["list of met requirements"],
              "requirements_missing": ["list of missing requirements"],
              "unresolved_comments": ["list of unresolved feedback"],
              "scope_issues": ["list of scope issues"],
              "summary": "Brief summary of your decision",
              "recommended_actions": ["list of actions if failed"]
            }
            ```

      - name: Extract review result
        id: extract
        run: |
          # Read execution file and extract JSON from Claude's response
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          # Default output based on conclusion
          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            # Extract the last assistant message text and find JSON
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)

            # Try to extract JSON block
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')

            # Validate and use or fallback
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          # Set simple outputs
          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":x:"
            STATUS_TEXT="FAILED"
          fi

          # Build comment body
          COMMENT_BODY="## Requirements Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add requirements met
          REQ_MET=$(echo "$OUTPUT" | jq -r '.requirements_met // [] | .[]' 2>/dev/null)
          if [ -n "$REQ_MET" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Requirements Met
          $(echo "$REQ_MET" | while read -r req; do echo "- :white_check_mark: $req"; done)
          "
          fi

          # Add missing requirements
          REQ_MISSING=$(echo "$OUTPUT" | jq -r '.requirements_missing // [] | .[]' 2>/dev/null)
          if [ -n "$REQ_MISSING" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Requirements Missing
          $(echo "$REQ_MISSING" | while read -r req; do echo "- :warning: $req"; done)
          "
          fi

          # Add unresolved comments
          UNRESOLVED=$(echo "$OUTPUT" | jq -r '.unresolved_comments // [] | .[]' 2>/dev/null)
          if [ -n "$UNRESOLVED" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Unresolved Comments
          $(echo "$UNRESOLVED" | while read -r comment; do echo "- :speech_balloon: $comment"; done)
          "
          fi

          # Add recommended actions
          ACTIONS=$(echo "$OUTPUT" | jq -r '.recommended_actions // [] | .[]' 2>/dev/null)
          if [ -n "$ACTIONS" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Recommended Actions
          $(echo "$ACTIONS" | while read -r action; do echo "1. $action"; done)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Requirements Review by Claude Code*"

          # Post or update comment
          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Requirements review passed"
          else
            STATE="failure"
            DESCRIPTION="Requirements review failed: $SUMMARY"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Requirements Review"

      - name: Fail if review failed
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::error::Requirements review failed. See PR comment for details."
            exit 1
          fi

  rules-review:
    needs: [check-prerequisites, requirements-review]
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract branch context
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number from branch
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          elif [[ $BRANCH_NAME =~ issue-([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | tr '\n' ' ' || echo "")
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT

          # Save changed files to file for Claude
          git diff --name-only HEAD~1 HEAD 2>/dev/null > /tmp/changed_files.txt || echo "" > /tmp/changed_files.txt

      - name: Get issue context
        id: issue
        if: steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.context.outputs.issue_number }}"

          # Get issue details
          gh issue view $ISSUE_NUM --json title,body,comments > /tmp/issue.json 2>/dev/null || echo "{}" > /tmp/issue.json

          echo "has_issue=true" >> $GITHUB_OUTPUT

      - name: Discover rules
        id: rules
        run: |
          # Find all rules files
          find .claude/rules -name "*.md" -type f 2>/dev/null > /tmp/rules_files.txt || echo "" > /tmp/rules_files.txt

          RULES_COUNT=$(wc -l < /tmp/rules_files.txt | tr -d ' ')
          echo "rules_count=$RULES_COUNT" >> $GITHUB_OUTPUT

          # Also check for project CLAUDE.md rules
          if [ -f "CLAUDE.md" ]; then
            echo "CLAUDE.md" >> /tmp/rules_files.txt
          fi

      - name: Rules Review with Claude
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(git diff:*),Bash(git log:*),Bash(cat:*),Bash(find:*)"
          max_turns: 20
          prompt: |
            # Rules Review Agent

            You are a rules compliance review agent. Your job is to verify that code changes comply with the project's rules defined in .claude/rules/*.md files.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue Number: ${{ steps.context.outputs.issue_number }}
            - Changed Files: ${{ steps.context.outputs.changed_files }}
            - Rules Count: ${{ steps.rules.outputs.rules_count }}

            ## Your Task

            1. **Read the changed files list**:
               - Read /tmp/changed_files.txt

            2. **Discover and read all rules**:
               - Read /tmp/rules_files.txt for list of rule files
               - Read each rule file in .claude/rules/
               - Each rule has frontmatter with path patterns (globs) that define which files it applies to

            3. **Group changed files by matching rules**:
               - For each changed file, find which rules apply based on path patterns in frontmatter
               - A file may match multiple rules
               - Track files that don't match any rule

            4. **For each rule-file group, evaluate compliance**:
               - Read the rule's requirements
               - Check if the changed files comply with those requirements
               - Identify any violations

            5. **Check for needed rule updates**:
               - Read /tmp/issue.json for linked issue context
               - Based on issue requirements and comments, identify if any rules need updating
               - This is a BLOCKING ERROR if rule updates seem clearly needed

            6. **Make your decision**:
               - PASS: All files comply with their matching rules
               - FAIL: Rule violations found, or rule updates needed

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - **Advise on rule fixes** - suggest what should be changed to comply
            - **Advise on rule updates** - if rules seem outdated based on issue/comments
            - **Blocking errors**: Rule updates needed = automatic FAIL

            ## Output Format

            Provide detailed rule-by-rule analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "rule_evaluations": [
                {
                  "rule_file": "path/to/rule.md",
                  "matched_files": ["file1.ts", "file2.ts"],
                  "compliant": true/false,
                  "violations": ["violation description"],
                  "suggestions": ["suggestion"]
                }
              ],
              "files_without_rules": ["files not covered by rules"],
              "rule_updates_needed": [
                {
                  "rule_file": "path/to/rule.md",
                  "reason": "why update needed",
                  "suggested_update": "what to change"
                }
              ],
              "blocking_errors": ["critical errors"],
              "summary": "Brief summary of your decision"
            }
            ```

      - name: Extract review result
        id: extract
        run: |
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":x:"
            STATUS_TEXT="FAILED"
          fi

          COMMENT_BODY="## Rules Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add rule evaluations
          RULE_EVALS=$(echo "$OUTPUT" | jq -c '.rule_evaluations // []')
          if [ "$RULE_EVALS" != "[]" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Rule Evaluations
          "
            echo "$OUTPUT" | jq -r '.rule_evaluations[]? | "#### \(.rule_file)\n- **Files:** \(.matched_files | join(\", \"))\n- **Compliant:** \(.compliant)\n\(.violations | if length > 0 then \"- **Violations:**\n\" + (map(\"  - \" + .) | join(\"\n\")) else \"\" end)\n"' 2>/dev/null | while IFS= read -r line; do
              COMMENT_BODY="${COMMENT_BODY}${line}
          "
            done
          fi

          # Add blocking errors
          BLOCKING=$(echo "$OUTPUT" | jq -r '.blocking_errors // [] | .[]' 2>/dev/null)
          if [ -n "$BLOCKING" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### :rotating_light: Blocking Errors
          $(echo "$BLOCKING" | while read -r err; do echo "- $err"; done)
          "
          fi

          # Add rule updates needed
          UPDATES=$(echo "$OUTPUT" | jq -c '.rule_updates_needed // []')
          if [ "$UPDATES" != "[]" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Rule Updates Needed
          $(echo "$OUTPUT" | jq -r '.rule_updates_needed[]? | "- **\(.rule_file)**: \(.reason)"' 2>/dev/null)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Rules Review by Claude Code*"

          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Rules review passed"
          else
            STATE="failure"
            DESCRIPTION="Rules review failed: $SUMMARY"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Rules Review"

      - name: Fail if review failed
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::error::Rules review failed. See PR comment for details."
            exit 1
          fi

  project-memory-review:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if path filter applies
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            memory:
              - 'CLAUDE.md'
              - '**/CLAUDE.md'
              - '.claude/**'

      - name: Extract context
        if: steps.filter.outputs.memory == 'true'
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get all changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' > /tmp/all_changed_files.txt
          else
            git diff --name-only HEAD~1 HEAD > /tmp/all_changed_files.txt 2>/dev/null || echo "" > /tmp/all_changed_files.txt
          fi

          # Find touched CLAUDE.md files
          grep -E '(^|/)CLAUDE\.md$' /tmp/all_changed_files.txt > /tmp/changed_claude_files.txt || echo "" > /tmp/changed_claude_files.txt

          # Find folders touched by the commit (to check their CLAUDE.md files)
          cat /tmp/all_changed_files.txt | while read -r file; do
            dir=$(dirname "$file")
            while [ "$dir" != "." ]; do
              if [ -f "$dir/CLAUDE.md" ]; then
                echo "$dir/CLAUDE.md"
              fi
              dir=$(dirname "$dir")
            done
          done | sort -u > /tmp/folder_claude_files.txt

          # Combine touched and folder CLAUDE.md files
          cat /tmp/changed_claude_files.txt /tmp/folder_claude_files.txt | sort -u > /tmp/relevant_claude_files.txt

          # Always include root CLAUDE.md if it exists
          if [ -f "CLAUDE.md" ]; then
            echo "CLAUDE.md" >> /tmp/relevant_claude_files.txt
          fi

          sort -u /tmp/relevant_claude_files.txt -o /tmp/relevant_claude_files.txt

      - name: Get issue context
        if: steps.filter.outputs.memory == 'true' && steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue view ${{ steps.context.outputs.issue_number }} --json title,body,comments > /tmp/issue.json 2>/dev/null || echo "{}" > /tmp/issue.json

      - name: Get PR comments
        if: steps.filter.outputs.memory == 'true' && github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr view ${{ github.event.pull_request.number }} --json comments,reviews > /tmp/pr_comments.json 2>/dev/null || echo "{}" > /tmp/pr_comments.json

      - name: Project Memory Review with Claude
        if: steps.filter.outputs.memory == 'true'
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(cat:*),Bash(find:*),Bash(git diff:*),Bash(git log:*)"
          max_turns: 20
          prompt: |
            # Project Memory Review Agent

            You are a project memory review agent. Your job is to verify that code changes comply with the rules and requirements documented in CLAUDE.md files.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue: ${{ steps.context.outputs.issue_number }}

            ## Your Task

            1. **Identify relevant CLAUDE.md files**:
               - Read /tmp/relevant_claude_files.txt for list of CLAUDE.md files to check
               - Read /tmp/all_changed_files.txt for all files changed in this commit

            2. **For each CLAUDE.md file**:
               - Read the CLAUDE.md content
               - Extract rules and requirements from it
               - Identify which changed files should comply with these rules
               - Check if the changes comply with the documented requirements

            3. **Check for needed updates**:
               - Read /tmp/issue.json for linked issue context
               - Read /tmp/pr_comments.json for PR feedback
               - Based on issue/comments, identify if CLAUDE.md files need updating

            4. **Evaluate compliance**:
               - For each rule in each CLAUDE.md:
                 - Is it met by the code changes?
                 - Are there violations?
                 - Should the rule be updated based on issue context?

            5. **Make your decision**:
               - PASS: All documented rules/requirements met
               - FAIL: Rule violations found or critical updates needed

            ## CLAUDE.md Structure

            CLAUDE.md files typically contain:
            - Frontmatter with metadata (folder structure, allowed files, etc.)
            - Project description and architecture
            - Development rules and guidelines
            - Technology-specific requirements
            - Best practices to follow

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - Check both root CLAUDE.md and folder-specific ones
            - Folder CLAUDE.md rules apply to files in that folder
            - Suggest documentation updates if issue context indicates needs
            - Be specific about which rules are violated and where

            ## Output Format

            Provide file-by-file analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "claude_file_evaluations": [
                {
                  "claude_file": "path/to/CLAUDE.md",
                  "rules_extracted": ["rule descriptions"],
                  "rules_met": ["met rules"],
                  "rules_violated": [
                    {
                      "rule": "rule name",
                      "violation": "description",
                      "affected_files": ["file1.ts"]
                    }
                  ],
                  "update_suggestions": ["suggestions"]
                }
              ],
              "documentation_updates_needed": [
                {
                  "file": "path/to/file",
                  "reason": "why update needed",
                  "suggested_change": "what to change"
                }
              ],
              "blocking_violations": ["critical violations"],
              "summary": "Brief summary of your decision"
            }
            ```

      - name: Extract review result
        if: steps.filter.outputs.memory == 'true'
        id: extract
        run: |
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: steps.filter.outputs.memory == 'true' && github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":x:"
            STATUS_TEXT="FAILED"
          fi

          COMMENT_BODY="## Project Memory Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add file evaluations
          echo "$OUTPUT" | jq -r '.claude_file_evaluations[]? | "### \(.claude_file)\n\n**Rules Extracted:** \(.rules_extracted | length)\n\n**Rules Met:**\n\(.rules_met | if length > 0 then map(\"- :white_check_mark: \" + .) | join(\"\n\") else \"None specified\" end)\n\n**Violations:**\n\(.rules_violated | if length > 0 then map(\"- :x: **\" + .rule + \"**: \" + .violation + \" (Files: \" + (.affected_files | join(\", \")) + \")\") | join(\"\n\") else \"None\" end)\n"' 2>/dev/null | while IFS= read -r line; do
            COMMENT_BODY="${COMMENT_BODY}${line}
          "
          done

          # Add blocking violations
          BLOCKING=$(echo "$OUTPUT" | jq -r '.blocking_violations // [] | .[]' 2>/dev/null)
          if [ -n "$BLOCKING" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### :rotating_light: Blocking Violations
          $(echo "$BLOCKING" | while read -r v; do echo "- $v"; done)
          "
          fi

          # Add documentation update suggestions
          DOC_UPDATES=$(echo "$OUTPUT" | jq -c '.documentation_updates_needed // []')
          if [ "$DOC_UPDATES" != "[]" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Documentation Updates Suggested
          $(echo "$OUTPUT" | jq -r '.documentation_updates_needed[]? | "- **\(.file)**: \(.reason)"' 2>/dev/null)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Project Memory Review by Claude Code*"

          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        if: steps.filter.outputs.memory == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Project memory review passed"
          else
            STATE="failure"
            DESCRIPTION="Project memory violations found"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Project Memory Review"

      - name: Fail if review failed
        if: steps.filter.outputs.memory == 'true'
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::error::Project memory review failed. See PR comment for details."
            exit 1
          fi

  agents-review:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if path filter applies
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            agents:
              - '.claude/agents/**'
              - 'agents/**'
              - '**/agents/*.md'

      - name: Extract context
        if: steps.filter.outputs.agents == 'true'
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get changed agent files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_AGENTS=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep -E '(agents/.*\.md|AGENT\.md)' || echo "")
          else
            CHANGED_AGENTS=$(git diff --name-only HEAD~1 HEAD | grep -E '(agents/.*\.md|AGENT\.md)' || echo "")
          fi
          echo "$CHANGED_AGENTS" > /tmp/changed_agents.txt
          echo "changed_agents=$CHANGED_AGENTS" >> $GITHUB_OUTPUT

      - name: Get issue context
        if: steps.filter.outputs.agents == 'true' && steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue view ${{ steps.context.outputs.issue_number }} --json title,body,comments > /tmp/issue.json 2>/dev/null || echo "{}" > /tmp/issue.json

      - name: Agents Review with Claude
        if: steps.filter.outputs.agents == 'true'
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(cat:*),Bash(find:*)"
          max_turns: 15
          prompt: |
            # Agents Review Agent

            You are an agents review specialist focused on context optimization. Your job is to review .claude/agents/*.md files for quality, completeness, and context efficiency.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue: ${{ steps.context.outputs.issue_number }}
            - Changed Agents: Read /tmp/changed_agents.txt

            ## Agent Quality Criteria

            1. **Frontmatter Requirements**:
               - `description`: Clear, concise purpose (1-2 sentences)
               - `capabilities`: Array of specific capabilities
               - Optional: `color`, `model`, `tools`

            2. **Content Structure**:
               - Clear heading with agent name
               - Detailed description of role and expertise
               - When to use (triggering conditions)
               - What the agent does (step-by-step)
               - What it doesn't do (boundaries)

            3. **Context Optimization**:
               - Is the description too verbose? (wastes context tokens)
               - Is it too vague? (causes confusion)
               - Are capabilities specific and actionable?
               - Does it avoid duplicating system knowledge?
               - Does it focus on domain-specific guidance?

            4. **Integration Quality**:
               - Does the when-to-use section help Claude decide correctly?
               - Are there clear boundaries to prevent scope creep?
               - Is the agent focused on ONE specialized domain?

            ## Your Task

            1. Read each changed agent file
            2. Evaluate against the criteria above
            3. Check if issue context suggests any needed updates
            4. Identify context optimization opportunities
            5. Provide specific, actionable suggestions

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - Focus on context optimization (smaller = better if equally clear)
            - Prefer specific examples over abstract descriptions
            - Flag agents that try to do too much (should be split)

            ## Output Format

            Provide agent-by-agent analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "agent_evaluations": [
                {
                  "agent_file": "path/to/agent.md",
                  "frontmatter_valid": true/false,
                  "context_score": 1-10,
                  "clarity_score": 1-10,
                  "focus_score": 1-10,
                  "issues": ["issue descriptions"],
                  "suggestions": ["suggestions"]
                }
              ],
              "optimization_opportunities": ["opportunities for context optimization"],
              "summary": "Brief summary of your decision"
            }
            ```

      - name: Extract review result
        if: steps.filter.outputs.agents == 'true'
        id: extract
        run: |
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: steps.filter.outputs.agents == 'true' && github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":warning:"
            STATUS_TEXT="NEEDS IMPROVEMENT"
          fi

          COMMENT_BODY="## Agents Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add agent evaluations
          echo "$OUTPUT" | jq -r '.agent_evaluations[]? | "### \(.agent_file)\n- **Context Score:** \(.context_score)/10\n- **Clarity Score:** \(.clarity_score)/10\n- **Focus Score:** \(.focus_score)/10\n- **Frontmatter Valid:** \(.frontmatter_valid)\n\n**Issues:**\n\(.issues | if length > 0 then map(\"- \" + .) | join(\"\n\") else \"None\" end)\n\n**Suggestions:**\n\(.suggestions | if length > 0 then map(\"- \" + .) | join(\"\n\") else \"None\" end)\n"' 2>/dev/null | while IFS= read -r line; do
            COMMENT_BODY="${COMMENT_BODY}${line}
          "
          done

          # Add optimization opportunities
          OPTS=$(echo "$OUTPUT" | jq -r '.optimization_opportunities // [] | .[]' 2>/dev/null)
          if [ -n "$OPTS" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Context Optimization Opportunities
          $(echo "$OPTS" | while read -r opt; do echo "- :zap: $opt"; done)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Agents Review by Claude Code*"

          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        if: steps.filter.outputs.agents == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Agents review passed"
          else
            STATE="failure"
            DESCRIPTION="Agents need improvement"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Agents Review"

      - name: Fail if review failed
        if: steps.filter.outputs.agents == 'true'
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::warning::Agents review identified improvements needed. See PR comment."
            exit 1
          fi

  skills-review:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if path filter applies
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            skills:
              - '.claude/skills/**'
              - 'skills/**'
              - '**/SKILL.md'

      - name: Extract context
        if: steps.filter.outputs.skills == 'true'
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get changed skill files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_SKILLS=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep -E '(skills/.*\.md|SKILL\.md)' || echo "")
          else
            CHANGED_SKILLS=$(git diff --name-only HEAD~1 HEAD | grep -E '(skills/.*\.md|SKILL\.md)' || echo "")
          fi
          echo "$CHANGED_SKILLS" > /tmp/changed_skills.txt
          echo "changed_skills=$CHANGED_SKILLS" >> $GITHUB_OUTPUT

      - name: Get issue context
        if: steps.filter.outputs.skills == 'true' && steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue view ${{ steps.context.outputs.issue_number }} --json title,body,comments > /tmp/issue.json 2>/dev/null || echo "{}" > /tmp/issue.json

      - name: Skills Review with Claude
        if: steps.filter.outputs.skills == 'true'
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(cat:*),Bash(find:*)"
          max_turns: 15
          prompt: |
            # Skills Review Agent

            You are a skills review specialist focused on context optimization. Your job is to review .claude/skills/**/SKILL.md files for quality, structure, and context efficiency.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue: ${{ steps.context.outputs.issue_number }}
            - Changed Skills: Read /tmp/changed_skills.txt

            ## Skill Quality Criteria

            1. **Frontmatter Requirements**:
               - `description`: Clear, concise skill purpose (triggers skill invocation)
               - `capabilities`: Array of specific things the skill enables
               - Optional: `required_skills`, `related_skills`

            2. **Content Structure**:
               - Clear title heading
               - Overview section explaining the skill
               - Detailed guidance organized with sub-headings
               - Examples with code blocks where appropriate
               - Links to official documentation (prefer .md URLs)

            3. **Context Optimization**:
               - Is the skill focused on ONE topic?
               - Does it avoid duplicating general knowledge?
               - Is content dense with actionable guidance?
               - Are examples minimal but representative?
               - Could any sections be split to separate skills?

            4. **Progressive Disclosure**:
               - Is the most important info at the top?
               - Are details progressively revealed?
               - Can Claude find key info quickly?

            5. **Documentation Links**:
               - Are there links to official docs?
               - Are .md file URLs preferred over HTML?
               - Are links current and accessible?

            ## Your Task

            1. Read each changed skill file
            2. Evaluate against the criteria above
            3. Check if issue context suggests needed updates
            4. Identify context optimization opportunities
            5. Provide specific, actionable suggestions

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - Focus on context efficiency (every token should add value)
            - Skills should be self-contained but not redundant
            - Flag skills that are too broad or try to cover too much

            ## Output Format

            Provide skill-by-skill analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "skill_evaluations": [
                {
                  "skill_file": "path/to/SKILL.md",
                  "frontmatter_valid": true/false,
                  "context_efficiency": 1-10,
                  "structure_score": 1-10,
                  "documentation_links": true/false,
                  "progressive_disclosure": true/false,
                  "issues": ["issue descriptions"],
                  "suggestions": ["suggestions"]
                }
              ],
              "optimization_opportunities": ["opportunities"],
              "split_recommendations": [
                {
                  "skill_file": "path/to/SKILL.md",
                  "reason": "why split needed",
                  "suggested_split": ["new-skill-1", "new-skill-2"]
                }
              ],
              "summary": "Brief summary of your decision"
            }
            ```

      - name: Extract review result
        if: steps.filter.outputs.skills == 'true'
        id: extract
        run: |
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: steps.filter.outputs.skills == 'true' && github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":warning:"
            STATUS_TEXT="NEEDS IMPROVEMENT"
          fi

          COMMENT_BODY="## Skills Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add skill evaluations
          echo "$OUTPUT" | jq -r '.skill_evaluations[]? | "### \(.skill_file)\n- **Context Efficiency:** \(.context_efficiency)/10\n- **Structure Score:** \(.structure_score)/10\n- **Has Doc Links:** \(.documentation_links)\n- **Progressive Disclosure:** \(.progressive_disclosure)\n\n**Issues:**\n\(.issues | if length > 0 then map(\"- \" + .) | join(\"\n\") else \"None\" end)\n\n**Suggestions:**\n\(.suggestions | if length > 0 then map(\"- \" + .) | join(\"\n\") else \"None\" end)\n"' 2>/dev/null | while IFS= read -r line; do
            COMMENT_BODY="${COMMENT_BODY}${line}
          "
          done

          # Add optimization opportunities
          OPTS=$(echo "$OUTPUT" | jq -r '.optimization_opportunities // [] | .[]' 2>/dev/null)
          if [ -n "$OPTS" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Context Optimization Opportunities
          $(echo "$OPTS" | while read -r opt; do echo "- :zap: $opt"; done)
          "
          fi

          # Add split recommendations
          SPLITS=$(echo "$OUTPUT" | jq -c '.split_recommendations // []')
          if [ "$SPLITS" != "[]" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Skill Split Recommendations
          $(echo "$OUTPUT" | jq -r '.split_recommendations[]? | "- **\(.skill_file)**: \(.reason)\n  - Suggested: \(.suggested_split | join(\", \"))"' 2>/dev/null)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Skills Review by Claude Code*"

          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        if: steps.filter.outputs.skills == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Skills review passed"
          else
            STATE="failure"
            DESCRIPTION="Skills need improvement"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Skills Review"

      - name: Fail if review failed
        if: steps.filter.outputs.skills == 'true'
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::warning::Skills review identified improvements needed. See PR comment."
            exit 1
          fi

  playwright-ui-review:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if path filter applies
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            ui:
              - 'apps/**'
              - 'packages/ui/**'
              - '**/*.tsx'
              - '**/*.css'
              - '**/tailwind.config.*'

      - name: Download screenshots
        if: steps.filter.outputs.ui == 'true'
        uses: actions/download-artifact@v4
        with:
          name: playwright-screenshots-${{ github.sha }}
          path: .claude/screenshots/
        continue-on-error: true

      - name: Extract context
        if: steps.filter.outputs.ui == 'true'
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Get changed UI files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | grep -E '\.(tsx|css|scss)$' || echo "")
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E '\.(tsx|css|scss)$' || echo "")
          fi
          echo "$CHANGED_FILES" > /tmp/changed_ui_files.txt

          # Check for screenshots
          SCREENSHOT_COUNT=$(ls -1 .claude/screenshots/*.png 2>/dev/null | wc -l)
          echo "screenshot_count=$SCREENSHOT_COUNT" >> $GITHUB_OUTPUT

      - name: Gather UI rules
        if: steps.filter.outputs.ui == 'true'
        id: rules
        run: |
          # Find UI-related rules
          mkdir -p /tmp/ui-rules

          # Look for ui-prefixed skills
          find .claude/skills -name "ui-*" -type d 2>/dev/null | while read -r dir; do
            if [ -f "$dir/SKILL.md" ]; then
              cp "$dir/SKILL.md" "/tmp/ui-rules/$(basename $dir).md"
            fi
          done

          # Look for UI rules in .claude/rules
          find .claude/rules -name "ui-*" -o -name "*-ui-*" 2>/dev/null | while read -r file; do
            cp "$file" "/tmp/ui-rules/" 2>/dev/null || true
          done

          # Count rules found
          RULES_COUNT=$(ls -1 /tmp/ui-rules/*.md 2>/dev/null | wc -l)
          echo "rules_count=$RULES_COUNT" >> $GITHUB_OUTPUT

      - name: UI Review with Claude
        if: steps.filter.outputs.ui == 'true'
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(cat:*),Bash(find:*),Bash(ls:*)"
          max_turns: 25
          model: claude-sonnet-4-5-20250929
          prompt: |
            # Playwright UI Review Agent

            You are a UI review specialist. Your job is to review UI screenshots from Playwright tests and evaluate them against UI rules and modern best practices.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Screenshot Count: ${{ steps.context.outputs.screenshot_count }}
            - UI Rules Count: ${{ steps.rules.outputs.rules_count }}

            ## Your Task

            1. **Review screenshots** (in .claude/screenshots/):
               - Read the screenshot manifest: .claude/screenshot-manifest.txt
               - View each screenshot file
               - Note the file path for context on what UI element it shows

            2. **Check against UI rules** (in /tmp/ui-rules/):
               - Read each UI rule/skill file
               - Evaluate screenshots against documented standards

            3. **Evaluate against modern UI best practices**:

               **Visual Design:**
               - Clear visual hierarchy
               - Consistent spacing (8px grid)
               - Accessible color contrast (WCAG 2.1 AA: 4.5:1 minimum)
               - Readable typography
               - Dark/light mode support if applicable

               **Layout & Responsiveness:**
               - Mobile-first approach
               - Proper responsive breakpoints
               - No layout shifts or overflow issues

               **Accessibility:**
               - Visible focus indicators
               - Proper touch targets (44x44px minimum)
               - Semantic structure visible in UI

               **User Experience:**
               - Clear call-to-action buttons
               - Logical flow and navigation
               - Loading and error states handled
               - Empty states designed

               **Modern Elegance:**
               - Clean, uncluttered design
               - Consistent component styling
               - Appropriate use of whitespace
               - Professional and polished appearance

            4. **Categorize issues**:
               - **Critical**: Broken layout, missing content, accessibility violations
               - **Major**: Poor UX, inconsistent styling, confusing navigation
               - **Minor**: Small visual tweaks, optimization opportunities

            5. **Make your decision**:
               - PASS: No critical issues, acceptable visual quality
               - FAIL: Critical issues found

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - If no screenshots available, note this and skip visual review
            - Be specific about which screenshot shows each issue
            - Suggest concrete improvements

            ## Output Format

            Provide screenshot-by-screenshot analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "tests_passed": true/false,
              "screenshot_reviews": [
                {
                  "screenshot_path": "path/to/screenshot.png",
                  "description": "what this screenshot shows",
                  "critical_issues": ["critical issues"],
                  "major_issues": ["major issues"],
                  "minor_issues": ["minor issues"],
                  "positive_aspects": ["good things"]
                }
              ],
              "rule_compliance": [
                {
                  "rule": "rule name",
                  "compliant": true/false,
                  "violations": ["violations"]
                }
              ],
              "best_practices_evaluation": {
                "visual_design": 1-10,
                "layout_responsiveness": 1-10,
                "accessibility": 1-10,
                "user_experience": 1-10,
                "modern_elegance": 1-10
              },
              "total_critical": 0,
              "total_major": 0,
              "total_minor": 0,
              "top_recommendations": ["recommendations"],
              "summary": "Brief summary of your decision"
            }
            ```

      - name: Extract review result
        if: steps.filter.outputs.ui == 'true'
        id: extract
        run: |
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"tests_passed":true,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"tests_passed":false,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          TESTS_PASSED=$(jq -r '.tests_passed // false' /tmp/review_output.json)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          echo "tests_passed=$TESTS_PASSED" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: steps.filter.outputs.ui == 'true' && github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')
          TESTS_PASSED=$(echo "$OUTPUT" | jq -r '.tests_passed // false')

          CRITICAL=$(echo "$OUTPUT" | jq -r '.total_critical // 0')
          MAJOR=$(echo "$OUTPUT" | jq -r '.total_major // 0')
          MINOR=$(echo "$OUTPUT" | jq -r '.total_minor // 0')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":x:"
            STATUS_TEXT="FAILED"
          fi

          COMMENT_BODY="## Playwright UI Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}
          **Tests Passed:** $TESTS_PASSED

          ### Issue Summary
          | Level | Count |
          |-------|-------|
          | :rotating_light: Critical | ${CRITICAL} |
          | :warning: Major | ${MAJOR} |
          | :information_source: Minor | ${MINOR} |

          ### Summary
          ${SUMMARY}
          "

          # Add best practices scores
          BP=$(echo "$OUTPUT" | jq '.best_practices_evaluation // {}')
          if [ "$BP" != "{}" ]; then
            VISUAL=$(echo "$BP" | jq -r '.visual_design // "N/A"')
            LAYOUT=$(echo "$BP" | jq -r '.layout_responsiveness // "N/A"')
            A11Y=$(echo "$BP" | jq -r '.accessibility // "N/A"')
            UX=$(echo "$BP" | jq -r '.user_experience // "N/A"')
            ELEGANCE=$(echo "$BP" | jq -r '.modern_elegance // "N/A"')

            COMMENT_BODY="${COMMENT_BODY}
          ### Best Practices Scores
          | Category | Score |
          |----------|-------|
          | Visual Design | ${VISUAL}/10 |
          | Layout & Responsiveness | ${LAYOUT}/10 |
          | Accessibility | ${A11Y}/10 |
          | User Experience | ${UX}/10 |
          | Modern Elegance | ${ELEGANCE}/10 |
          "
          fi

          # Add top recommendations
          RECS=$(echo "$OUTPUT" | jq -r '.top_recommendations // [] | .[]' 2>/dev/null)
          if [ -n "$RECS" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Top Recommendations
          $(echo "$RECS" | while read -r rec; do echo "1. $rec"; done)
          "
          fi

          # Add critical issues if any
          if [ "$CRITICAL" -gt 0 ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### :rotating_light: Critical Issues
          $(echo "$OUTPUT" | jq -r '.screenshot_reviews[]? | select(.critical_issues | length > 0) | "**\(.screenshot_path)**:\n\(.critical_issues | map(\"- \" + .) | join(\"\n\"))"' 2>/dev/null)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Playwright UI Review by Claude Code*

          [View Screenshots Artifact](/${{ github.repository }}/actions/runs/${{ github.run_id }})"

          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        if: steps.filter.outputs.ui == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          OUTPUT=$(cat /tmp/review_output.json)
          CRITICAL=$(echo "$OUTPUT" | jq -r '.total_critical // 0')

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="UI review passed"
          else
            STATE="failure"
            DESCRIPTION="UI review failed: ${CRITICAL} critical issues"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Playwright UI Review"

      - name: Fail if review failed
        if: steps.filter.outputs.ui == 'true'
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::error::UI review failed. See PR comment for details."
            exit 1
          fi
