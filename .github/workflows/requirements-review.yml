name: Requirements Review

# Reviews code changes against linked issue requirements
# Runs on every commit, checks issue connected to branch, PR comments
# Advises on requirement changes, posts comments - DOES NOT edit files

on:
  push:
    branches:
      - '**'
      - '!main'
  pull_request:
    branches:
      - '**'

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

concurrency:
  group: requirements-review-${{ github.ref }}
  cancel-in-progress: true

jobs:
  requirements-review:
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.passed }}
      structured_output: ${{ steps.review.outputs.structured_output }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract branch context
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Extract issue number from branch name patterns:
          # feature/123-description, fix/issue-456, 123-my-feature
          ISSUE_NUMBER=""
          if [[ $BRANCH_NAME =~ ^(feature|fix|bugfix|hotfix)/([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[2]}"
          elif [[ $BRANCH_NAME =~ ^([0-9]+)- ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          elif [[ $BRANCH_NAME =~ issue-([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi

          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path' | tr '\n' ' ')
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | tr '\n' ' ' || echo "")
          fi
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT

      - name: Get issue content
        id: issue
        if: steps.context.outputs.issue_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.context.outputs.issue_number }}"

          # Get issue details
          ISSUE_TITLE=$(gh issue view $ISSUE_NUM --json title --jq '.title' 2>/dev/null || echo "")
          ISSUE_BODY=$(gh issue view $ISSUE_NUM --json body --jq '.body' 2>/dev/null || echo "")

          # Get issue comments
          ISSUE_COMMENTS=$(gh issue view $ISSUE_NUM --json comments --jq '.comments[].body' 2>/dev/null | head -c 5000 || echo "")

          # Save to files for Claude to read
          echo "$ISSUE_TITLE" > /tmp/issue_title.txt
          echo "$ISSUE_BODY" > /tmp/issue_body.txt
          echo "$ISSUE_COMMENTS" > /tmp/issue_comments.txt

          echo "has_issue=true" >> $GITHUB_OUTPUT

      - name: Get PR comments
        id: pr_comments
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"

          # Get PR comments
          PR_COMMENTS=$(gh pr view $PR_NUM --json comments --jq '.comments[].body' 2>/dev/null | head -c 5000 || echo "")

          # Get review comments
          REVIEW_COMMENTS=$(gh pr view $PR_NUM --json reviews --jq '.reviews[].body' 2>/dev/null | head -c 3000 || echo "")

          echo "$PR_COMMENTS" > /tmp/pr_comments.txt
          echo "$REVIEW_COMMENTS" > /tmp/review_comments.txt

          echo "has_pr_comments=true" >> $GITHUB_OUTPUT

      - name: Requirements Review with Claude
        id: review
        uses: anthropics/claude-code-base-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          allowed_tools: "View,GlobTool,Grep,Bash(git diff:*),Bash(git log:*),Bash(cat:*)"
          max_turns: 15
          prompt: |
            # Requirements Review Agent

            You are a requirements review agent. Your job is to verify that code changes align with the linked issue requirements and any comments/feedback.

            ## Context
            - Branch: ${{ steps.context.outputs.branch_name }}
            - Issue Number: ${{ steps.context.outputs.issue_number }}
            - Changed Files: ${{ steps.context.outputs.changed_files }}
            - Event: ${{ github.event_name }}
            - PR Number: ${{ github.event.pull_request.number || 'N/A' }}

            ## Your Task

            1. **Read the linked issue** (if available):
               - Issue title: Read /tmp/issue_title.txt
               - Issue body: Read /tmp/issue_body.txt
               - Issue comments: Read /tmp/issue_comments.txt

            2. **Read PR/branch comments** (if available):
               - PR comments: Read /tmp/pr_comments.txt
               - Review comments: Read /tmp/review_comments.txt

            3. **Analyze the code changes**:
               - Review git diff for the changed files
               - Understand what was implemented

            4. **Compare requirements vs implementation**:
               - Does the code address all requirements from the issue?
               - Are there any comments that indicate needed changes?
               - Are there any scope creep issues (implementation beyond requirements)?
               - Are there missing requirements?

            5. **Make your decision**:
               - PASS: All requirements addressed, comments resolved
               - FAIL: Requirements not met, unresolved feedback, or scope issues

            ## IMPORTANT RULES

            - **DO NOT edit any files** - you are a reviewer only
            - **Prioritize comments** over original issue if they indicate requirement changes
            - If there's no linked issue, focus on PR comments and code quality
            - If no issue AND no comments, provide general assessment and PASS

            ## Output Format

            Provide a detailed analysis, then output your final decision as a JSON code block.

            Your response MUST end with a JSON code block in this exact format:

            ```json
            {
              "passed": true/false,
              "confidence": 0.0-1.0,
              "requirements_met": ["list of met requirements"],
              "requirements_missing": ["list of missing requirements"],
              "unresolved_comments": ["list of unresolved feedback"],
              "scope_issues": ["list of scope issues"],
              "summary": "Brief summary of your decision",
              "recommended_actions": ["list of actions if failed"]
            }
            ```

      - name: Extract review result
        id: extract
        run: |
          # Read execution file and extract JSON from Claude's response
          EXEC_FILE="${{ steps.review.outputs.execution_file }}"
          CONCLUSION="${{ steps.review.outputs.conclusion }}"

          # Default output based on conclusion
          if [ "$CONCLUSION" = "success" ]; then
            DEFAULT_OUTPUT='{"passed":true,"confidence":0.8,"summary":"Review completed successfully"}'
          else
            DEFAULT_OUTPUT='{"passed":false,"confidence":0.5,"summary":"Review completed with issues"}'
          fi

          if [ -f "$EXEC_FILE" ]; then
            # Extract the last assistant message text and find JSON
            LAST_TEXT=$(jq -r '[.[] | select(.type == "assistant") | .message.content[]? | select(.type == "text") | .text] | last // ""' "$EXEC_FILE" 2>/dev/null)

            # Try to extract JSON block
            OUTPUT=$(echo "$LAST_TEXT" | sed -n '/```json/,/```/{/```json/d;/```/d;p;}' | tr -d '\r')

            # Validate and use or fallback
            if echo "$OUTPUT" | jq . >/dev/null 2>&1 && [ -n "$OUTPUT" ]; then
              echo "$OUTPUT" > /tmp/review_output.json
            else
              echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
            fi
          else
            echo "$DEFAULT_OUTPUT" > /tmp/review_output.json
          fi

          # Set simple outputs
          PASSED=$(jq -r '.passed // false' /tmp/review_output.json)
          SUMMARY=$(jq -r '.summary // "No summary"' /tmp/review_output.json | head -c 200)
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review comment
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(cat /tmp/review_output.json)
          PASSED=$(echo "$OUTPUT" | jq -r '.passed // false')
          CONFIDENCE=$(echo "$OUTPUT" | jq -r '.confidence // 0')
          SUMMARY=$(echo "$OUTPUT" | jq -r '.summary // "No summary available"')

          if [ "$PASSED" = "true" ]; then
            STATUS_ICON=":white_check_mark:"
            STATUS_TEXT="PASSED"
          else
            STATUS_ICON=":x:"
            STATUS_TEXT="FAILED"
          fi

          # Build comment body
          COMMENT_BODY="## Requirements Review ${STATUS_ICON} ${STATUS_TEXT}

          **Confidence:** ${CONFIDENCE}

          ### Summary
          ${SUMMARY}
          "

          # Add requirements met
          REQ_MET=$(echo "$OUTPUT" | jq -r '.requirements_met // [] | .[]' 2>/dev/null)
          if [ -n "$REQ_MET" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Requirements Met
          $(echo "$REQ_MET" | while read -r req; do echo "- :white_check_mark: $req"; done)
          "
          fi

          # Add missing requirements
          REQ_MISSING=$(echo "$OUTPUT" | jq -r '.requirements_missing // [] | .[]' 2>/dev/null)
          if [ -n "$REQ_MISSING" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Requirements Missing
          $(echo "$REQ_MISSING" | while read -r req; do echo "- :warning: $req"; done)
          "
          fi

          # Add unresolved comments
          UNRESOLVED=$(echo "$OUTPUT" | jq -r '.unresolved_comments // [] | .[]' 2>/dev/null)
          if [ -n "$UNRESOLVED" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Unresolved Comments
          $(echo "$UNRESOLVED" | while read -r comment; do echo "- :speech_balloon: $comment"; done)
          "
          fi

          # Add recommended actions
          ACTIONS=$(echo "$OUTPUT" | jq -r '.recommended_actions // [] | .[]' 2>/dev/null)
          if [ -n "$ACTIONS" ]; then
            COMMENT_BODY="${COMMENT_BODY}
          ### Recommended Actions
          $(echo "$ACTIONS" | while read -r action; do echo "1. $action"; done)
          "
          fi

          COMMENT_BODY="${COMMENT_BODY}

          ---
          *Automated Requirements Review by Claude Code*"

          # Post or update comment
          gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"

      - name: Set commit status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"
          SUMMARY="${{ steps.extract.outputs.summary }}"

          if [ "$PASSED" = "true" ]; then
            STATE="success"
            DESCRIPTION="Requirements review passed"
          else
            STATE="failure"
            DESCRIPTION="Requirements review failed: $SUMMARY"
          fi

          gh api repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -f state="$STATE" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="Requirements Review"

      - name: Fail if review failed
        run: |
          PASSED="${{ steps.extract.outputs.passed }}"

          if [ "$PASSED" != "true" ]; then
            echo "::error::Requirements review failed. See PR comment for details."
            exit 1
          fi
